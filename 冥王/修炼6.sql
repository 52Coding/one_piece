
网络互连7层、4层

物理连接、以太帧(链)、网络IP、传输点到点(p2p)、会话构建、格式转换(二进制转)、HTTP数据包(最终用户接口协议)

数据包 +++-> TCP头 +++-> IP头 +++-> 以太头

-- 有状态才需要保持~ 
关于http（自说自话）：
并不是无连接，而是短连接（用时建完事放），不止是短连接，还有keepalive
本身无状态（每次请求独立），但可以有状态（会话跟踪）

服务器发饼，小朋友带饼
Session 的实现依赖于 Cookie，如果 Cookie 被禁用，那么 session 也将失效。

CSRF，伪造合法请求，referer检测，token防御
XSS，脚本注入攻击，钓鱼，转义过滤或白名单防御

HTTP over TLS： RSA DES(AES) SHA256(完整性校验)


三次握手： 确认号与序列号有加一关系，加一表明 IamAlive
四次挥手： 同理

Creq - 收到回复 - 收到回复 
Cfinish - 收到回复 - Sfinish - 收到回复&等待超时

TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。

UDP 本身不提供确认，序列号，超时重传等机制。

#########################################################

资源是否是独占（独占锁 - 共享锁）
抢占不到资源怎么办（互斥锁 - 自旋锁）
自己能不能重复抢（重入锁 - 不可重入锁）
竞争读的情况比较多，读可不可以不加锁（读写锁）

容易看出，当资源等待的时间较长，用互斥锁让线程休眠，会消耗更少的资源。当资源等待的时间较短时，使用自旋锁将减少线程的切换，获得更高的性能。
较新版本的 Java 中的 synchornized 和 .NET 中的 lock（Monitor） 的实现，是结合了两种锁的特点。简单说，它们在发现资源被抢占之后，会先试着自旋等待一段时间，如果等待时间太长，则会进入挂起状态。通过这样的实现，可以较大程度上挖掘出锁的性能。

############################## NIO ~ 

垃圾回收机制。。。(主要从下面几方面解答 GC原理、最好画图解释一下年轻代（Eden区和Survival区）、年老代、比例分配及为啥要这样分代回收)
对象分配问题，堆栈里的问题，详细的会问道方法区、堆、程序计数器、本地方法栈、虚拟机栈，问题入口从String a,new String("")开始
关键字，private protected public static final 组合着问
Object类里面有哪几种方法，作用
equals 和 hashCode方法，重写equals的原则()
向上转型
Java引用类型(强引用，软引用，弱引用，虚引用)
线程相关的，主要是volitate，synchorized，wait()，notify()，notifyAll()，join()
Exception和Error
反射的用途
HashMap实现原理(数组+链表)，查找数据的时间复杂度
List有哪些子类，各有什么区别
NIO相关，缓冲区、通道、selector。。。(不熟，面了这么多，挂在这里。其实主要是表现在同步阻塞和异步，传输方式不同。标准IO无法实现非阻塞模式、文件锁、读选择、分散聚集等)
内存泄露，举个例子
OOM是怎么出现的，有哪几块JVM区域会产生OOM，如何解决(对于该问题，建议去《Java特种兵》的3.6章)
Java里面的观察者模式实现
单例实现(我一般用enum写，不容易被挑毛病)
用Java模拟一个栈，并能够做到扩容，并且能有同步锁。（用数组实现）
Java泛型机制，泛型机制的优点，以及类型变量

#######################

事务的特性
【事务隔离】级别与实现 （需要兼顾并发效率和异常控制）
资源竞争引发脏读、幻读（多线程 vs 多事务）
自记： 提交读（commit）、重复读
（避免在一个事务中对同一语句执行多次查询？）

共享锁、独占锁

############################ Java NIO 
Java NIO(New IO) （Non-blocking IO） 都OK。
标准的IO基于字节流和字符流进行操作的，而NIO是基于通道（Channel）和缓冲区（Buffer）进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。
Java NIO引入了选择器的概念，选择器用于【监听】多个通道的事件（比如：连接打开，数据到达）。因此，单个的线程可以监听多个数据通道。

IO                NIO
面向流            面向缓冲
阻塞IO            非阻塞IO
无                选择器

阻塞与非阻塞IO
Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。


NIO可让您只使用一个（或几个）单线程管理多个通道（网络连接或文件），但付出的代价是解析数据可能会比从一个阻塞流中读取数据更复杂。
Java NIO: 单线程管理多个连接
Java IO: 一个典型的IO服务器设计- 一个连接通过一个线程处理.
如果你有少量的连接使用非常高的带宽，一次发送大量的数据，也许典型的IO服务器实现可能非常契合。


http://ifeve.com/java-nio-all/

other refer！！